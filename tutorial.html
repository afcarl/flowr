<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc" />

    <meta name="author" content="Sahil Seth" />
  
    <meta name="date" content="2015-11-04" />
  
  <!---  <title>flowr</title> --->
  
  <title>flowr — Easy, scalable big data pipelines using High Performance Computing Cluster </title>
  <!---<link rel="shortcut icon" href="http://">--->
  <meta property="og:description" content="Easy, scalable big data pipelines using HPCC (high performance computing cluster)">
  <meta property="og:title" content="flowr — Easy, scalable big data pipelines using a Computing Cluster">
  <meta name="twitter:description" content="flowr - Easy, scalable big data pipelines using HPCC (high performance computing cluster)">
  <meta name="twitter:title" content="flowr — Easy, scalable big data pipelines using HPCC (high performance computing cluster)">
  <meta name="keywords" content="R, HPCC, computing, big data, genomics, bioinformatics, pipelines, workflow, ngs, next-generation, sequencing, wgs, wex">
  
  

    <script src="assets/jquery-1.11.0/jquery.min.js"></script>
  <link href="assets/bootstrap-3.3.2/css/bootstrap.min.css" rel="stylesheet" />
  <script src="assets/bootstrap-3.3.2/js/bootstrap.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/html5shiv.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/respond.min.js"></script>
  <link href="assets/highlight-8.4/tomorrow.css" rel="stylesheet" />
  <script src="assets/highlight-8.4/highlight.pack.js"></script>
  <link href="assets/fontawesome-4.3.0/css/font-awesome.min.css" rel="stylesheet" />
  <script src="assets/stickykit-1.1.1/sticky-kit.min.js"></script>
  <script src="assets/jqueryeasing-1.3/jquery.easing.min.js"></script>
  <link href="assets/packagedocs-0.0.1/pd.css" rel="stylesheet" />
  <script src="assets/packagedocs-0.0.1/pd.js"></script>
  <script src="assets/packagedocs-0.0.1/pd-sticky-toc.js"></script>
  <link href="assets/bootswatch-3.3.5/bootstrap.css" rel="stylesheet" />
  
  
  
  
  

	<!-- custom size -->
	<style>
  body {
  position: relative;
  padding-top: 40px;
  font-size: 15px;
  }
  
  .section h1 {
    margin-top: 30px;
    margin-bottom: 20px;
    border-bottom: 0px;
    font-size: 30px;
    font-weight: 400;
  }

 .section h2 {
    margin-top: 20px;
    margin-bottom: 10px;
    border-bottom: 0px;
    font-size: 22px;
    font-weight: 400;
  }
  
  pre {
  font-size:12px;
  padding: 0.3em;
  }
	</style>
	
	
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>

<body>

  
  <header class="navbar navbar-white navbar-fixed-top" role="banner" id="header">
    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
                <span class="navbar-brand">
<a href="http://docs.flowr.space"> <img src='files/logo_red.png' alt='flowr icon' width='50px' height='40px' style='margin-top: -20px;margin-bottom: -20px'> </a>
        </span>
                <a href="index.html" class="navbar-brand page-scroll">
<!--        flowr - Streamlining Workflows only subtitle-->
            Streamlining Workflows
        </a>
      </div>
            <nav class="collapse navbar-collapse" role="navigation">
        <ul class="nav nav-pills pull-right">
<li>
<a href='overview.html'>Overview</a>
</li>
<li>
<a href='install.html'>Install</a>
</li>
<li class="active">
<a href='Tutorial.html'>Tutorial</a>
</li>
<li>
<a href='rd.html'>Help</a>
</li>
<li>
<a href='news.html'>News</a>
</li>
<li>
<a href='https://github.com/sahilseth/flowr'>Github <i class='fa fa-github'></i></a>
</li>
        </ul>
      </nav>
          </div>
  </header>

  <!-- Begin Body -->
  <div class="container">
    <div class="row">
            <div class="col-md-3" id="sidebar-col">
        <div id="toc">
          <ul>
          <li><a href="#creating-input-files">Creating input file(s)</a><ul>
          <li><a href="#creating-flow-definition">Creating Flow Definition</a></li>
          <li><a href="#create-flow-submit-to-cluster">Create flow, submit to cluster</a></li>
          <li><a href="#creating-modules">Creating modules</a></li>
          </ul></li>
          <li><a href="#execute-the-pipeline">Execute the pipeline</a></li>
          <li><a href="#best-practices-for-writing-modulespipelines">Best practices for writing modules/pipelines</a><ul>
          <li><a href="#a-note-on-module-functions">A note on module functions</a></li>
          <li><a href="#pipeline-structure">Pipeline structure</a></li>
          <li><a href="#nomeclature-for-parameters">Nomeclature for parameters</a></li>
          </ul></li>
          </ul>
        </div>
      </div>
      <div class="col-md-9" id="content-col">
      
<div id="content-top"></div>
<div id="creating-input-files" class="section level1">
<h1>Creating input file(s)</h1>
<p>Let us use the same example described in the overview section. We start by getting a set of commands we would like to run.</p>
<pre><code>## wait for a few seconds…
sleep 5
sleep 5

## create two small files
cat $RANDOM &gt; tmp1
cat $RANDOM &gt; tmp2

## merge the two files
cat tmp1 tmp2 &gt; tmp

## check the size of the resulting file
du -sh tmp</code></pre>
<p><strong>Wrap these commands into R</strong></p>
<pre class="r"><code>sleep=c(&#39;sleep 5&#39;, &#39;sleep 5&#39;)

tmp=c(&#39;cat $RANDOM &gt; tmp1&#39;, 
            &#39;cat $RANDOM &gt; tmp2&#39;)
            
merge=&#39;cat tmp1 tmp2 &gt; tmp&#39;
            
size=&#39;du -sh tmp&#39;</code></pre>
<p>Next, we would create a table using the above commands:</p>
<pre class="r"><code>## create a table of all commands
library(flowr)
lst = list( sleep=sleep, 
           create_tmp=tmp, 
           merge=merge,
           size=size)

flowmat = to_flowmat(lst, &quot;samp1&quot;)
kable(flowmat)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">samplename</th>
<th align="left">jobname</th>
<th align="left">cmd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">samp1</td>
<td align="left">sleep</td>
<td align="left">sleep 5</td>
</tr>
<tr class="even">
<td align="left">samp1</td>
<td align="left">sleep</td>
<td align="left">sleep 5</td>
</tr>
<tr class="odd">
<td align="left">samp1</td>
<td align="left">create_tmp</td>
<td align="left">cat $RANDOM &gt; tmp1</td>
</tr>
<tr class="even">
<td align="left">samp1</td>
<td align="left">create_tmp</td>
<td align="left">cat $RANDOM &gt; tmp2</td>
</tr>
<tr class="odd">
<td align="left">samp1</td>
<td align="left">merge</td>
<td align="left">cat tmp1 tmp2 &gt; tmp</td>
</tr>
<tr class="even">
<td align="left">samp1</td>
<td align="left">size</td>
<td align="left">du -sh tmp</td>
</tr>
</tbody>
</table>
<div id="creating-flow-definition" class="section level2">
<h2>Creating Flow Definition</h2>
<p>We have a few steps in a pipeline; we would use a flow definition to descibe their flow. Flowr enables us to quickly create a skeleton flow definition using a flowmat, which we can then alter to suit our needs. A handy function <code>to_flowdef</code>, accepts a <code>flowmat</code> and creates a flow definition.</p>
<pre class="r"><code>## create a skeleton flow definition
def = to_flowdef(flowmat) 
suppressMessages(plot_flow(def))</code></pre>
<p><img src="tutorial_files/figure-html/plot_skeleton_def-1.png" title="" alt="" width="624" /></p>
<div class="alert alert-info" role="alert">
<p>The default skeleton takes a very conservative approach, creating all submissions as <strong>serial</strong> and all dependencies as <strong>gather</strong>. This ensures robustness, compromising efficiency. So customize this to make it super efficient.</p>
</div>
<p>We can make a few changes to make this pipeline a little more efficient. Briefly, we would run a few steps in a <strong>scatter</strong> fashion (in parallel).</p>
<p>A few points to note:</p>
<ul>
<li>Intial steps have no dependency, so their <strong>previous_jobs</strong> and <strong>dependency_type</strong> is <strong>none</strong>.</li>
<li>Steps with multiple commands, which can be run in parallel are submitted as <strong>scatter</strong>.</li>
<li>Steps with single commands are submitted as <strong>serial</strong>.</li>
<li>Say two consective steps run on small pieces of data, we have a <strong>serial</strong> <strong>one to one</strong> relationship. Example, both <strong>sleep</strong> and <strong>create_tmp</strong> are submitted as <strong>scatter</strong> and <strong>create_tmp</strong> has a dependency_type <strong>serial</strong>.</li>
<li>Finally if a step needs all the small pieces from a previous step, we use a <strong>gather</strong> type dependency.</li>
</ul>
<!-- multiple *sleep* commands would run as `scatter`/parallel, with `none` as the dependency.
- For each *sleep*, *create_tmp* creates a tmp file as `scatter`, using a `serial` type dependency. One `create_tmp` for one `sleep` (one-to-one relationship).
- Then all tmp files are *merged*. Intuitively, since this is a single step, we run it as `serial` and as all tmp files are required, we use a `gather` type dependency.
- Lastly, we need to check the *size* of the resulting merged file.
Again, since this is a single step, we run is as `serial`. More so since the previous step also had a single command, we use a `serial` type dependency.-->
<pre class="r"><code>##               sleep     create tmp   merge     size
def$sub_type = c(&quot;scatter&quot;, &quot;scatter&quot;, &quot;serial&quot;, &quot;serial&quot;)
def$dep_type = c(&quot;none&quot;, &quot;serial&quot;, &quot;gather&quot;, &quot;serial&quot;)
kable(def)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">jobname</th>
<th align="left">sub_type</th>
<th align="left">prev_jobs</th>
<th align="left">dep_type</th>
<th align="left">queue</th>
<th align="left">memory_reserved</th>
<th align="left">walltime</th>
<th align="right">cpu_reserved</th>
<th align="left">platform</th>
<th align="right">jobid</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sleep</td>
<td align="left">scatter</td>
<td align="left">none</td>
<td align="left">none</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">create_tmp</td>
<td align="left">scatter</td>
<td align="left">sleep</td>
<td align="left">serial</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">merge</td>
<td align="left">serial</td>
<td align="left">create_tmp</td>
<td align="left">gather</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">size</td>
<td align="left">serial</td>
<td align="left">merge</td>
<td align="left">serial</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">4</td>
</tr>
</tbody>
</table>
<p><img src="tutorial_files/figure-html/plot_tweaked_def-1.png" title="" alt="" width="624" /></p>
<div class="alert alert-info" role="alert">
<p><strong>Tip</strong> Alternatively, one may write this to a file (<strong>write_sheet(def, “sleep_pipe.def”)</strong>), make changes in a text editor and read it again (<strong>as.flowdef(“sleep_pipe.def”)</strong>.</p>
</div>
</div>
<div id="create-flow-submit-to-cluster" class="section level2">
<h2>Create flow, submit to cluster</h2>
<p><strong>Next, we create a flow object:</strong></p>
<pre class="r"><code>fobj = to_flow(flowmat, def, flowname = &quot;sleep_pipe&quot;)</code></pre>
<p><strong>Finally, we can submit this to the cluster:</strong></p>
<pre class="r"><code>plot_flow(fobj)
submit_flow(fobj) ## dry run
fobj2 = submit_flow(fobj, execute = TRUE) ## submission to LSF cluster

## after submission, we can use the following:
status(fobj2) ## check status
rerun(fobj2)  ## re-run from a intermediate step
kill(fobj2)   ## kill it!</code></pre>
</div>
<div id="creating-modules" class="section level2">
<h2>Creating modules</h2>
<p>We used a simple example where a single function was creating all the commands. This is easier, but a step (or module) is not re-usable in another pipeline. Thus we may write a module for each step, such that one may mix and match to create their own pipeline.</p>
<p><strong>NOTE:</strong> A module, always returns a flowmat. A module may have one or several steps. A module + flowdef, becomes a pipeline.</p>
<pre><code>## to follow this tutorial, you may download them:
url=https://raw.githubusercontent.com/sahilseth/flowr/master/inst/pipelines
cd ~/flowr/pipelines
wget $url/sleep_pipe.R ## A R script, with sleep_pipe(), which creates a flowmat
wget $url/sleep_pipe.def ## A tab-delimited flow definition file
wget $url/sleep_pipe.conf ## An *optional* tab-delim conf file, defining default params</code></pre>
<p>The <code>sleep_pipe</code> calls the three other functions (<strong>modules</strong>); fetches flowmat from each, then rbinds them, creating a larger flowmat. You may refer to the <a href="https://github.com/sahilseth/flowr/blob/master/inst/pipelines/sleep_pipe.R">sleep_pipe.R</a> file for the source.</p>
<pre class="r"><code>#&#39; @param x number of sleep commands
sleep &lt;- function(x, samplename){
    cmd = list(sleep = sprintf(&quot;sleep %s &amp;&amp; sleep %s;echo &#39;hello&#39;&quot;,
        abs(round(rnorm(x)*10, 0)),
        abs(round(rnorm(x)*10, 0))))
    flowmat = to_flowmat(cmd, samplename)
    return(list(flowmat = flowmat))
}

#&#39; @param x number of tmp commands
create_tmp &lt;- function(x, samplename){
    ## Create 100 temporary files
    tmp = sprintf(&quot;%s_tmp_%s&quot;, samplename, 1:x)
    cmd = list(create_tmp = sprintf(&quot;head -c 100000 /dev/urandom &gt; %s&quot;, tmp))
    ## --- convert the list into a data.frame
    flowmat = to_flowmat(cmd, samplename)
    return(list(flowmat = flowmat, outfiles = tmp))
}

#&#39; @param x vector of files to merge
merge_size &lt;- function(x, samplename){
    ## Merge them according to samples, 10 each
    mergedfile = paste0(samplename, &quot;_merged&quot;)
    cmd_merge &lt;- sprintf(&quot;cat %s &gt; %s&quot;,
        paste(x, collapse = &quot; &quot;), ## input files
        mergedfile)
    ## get the size of merged files
    cmd_size = sprintf(&quot;du -sh %s; echo &#39;MY shell:&#39; $SHELL&quot;, mergedfile)

    cmd = list(merge = cmd_merge, size = cmd_size)
    ## --- convert the list into a data.frame
    flowmat = to_flowmat(cmd, samplename)
    return(list(flowmat = flowmat, outfiles = mergedfile))
}</code></pre>
<pre class="r"><code>#&#39; @param x number of files to make
sleep_pipe &lt;- function(x = 3, samplename = &quot;samp1&quot;){

    ## call the modules one by one...
    out_sleep = sleep(x, samplename)
    out_create_tmp = create_tmp(x, samplename)
    out_merge_size = merge_size(out_create_tmp$outfiles, samplename)

    ## row bind all the commands
    flowmat = rbind(out_sleep$flowmat,
        out_create_tmp$flowmat,
        out_merge_size$flowmat)

    return(list(flowmat = flowmat, outfiles = out_merge_size$outfiles))
}</code></pre>
</div>
</div>
<div id="execute-the-pipeline" class="section level1">
<h1>Execute the pipeline</h1>
<p><strong>Using run</strong></p>
<p>One may use <code>run</code> function to create the flowmat, fetch the flowdef and execute the pipeline in a single step. Here we would focus more on each of these steps in detail.</p>
<pre class="r"><code>## 1. Single step submission:
fobj = run(&quot;sleep_pipe&quot;, execute = TRUE); 

## 2
## change wd, so that we can source the files downloaded in the previous step
setwd(&quot;~/flowr/pipelines&quot;)

## 2a. optionally, load default parameters
load_opts(&quot;sleep_pipe.conf&quot;) 

## 2b. get sleep_pipe() function
source(&quot;sleep_pipe.R&quot;) 
## create a flowmat
flowmat = sleep_pipe()

## 2c. read a flow definition.
flowdef = as.flowdef(&quot;sleep_pipe.def&quot;)

## 2d. create flow and submit to cluster
fobj = to_flow(flowmat, flowdef, execute = TRUE)</code></pre>
</div>
<div id="best-practices-for-writing-modulespipelines" class="section level1">
<h1>Best practices for writing modules/pipelines</h1>
<p>These are some of the practices we follow in-house. We feel using these makes stitching custom pipelines using a set of modules quite easy. Consider this a check-list of a few ideas and a work in progress.</p>
<div id="a-note-on-module-functions" class="section level2">
<h2>A note on module functions</h2>
<pre class="r"><code>picard_merge &lt;- function(x, 
                        samplename = get_opts(&quot;samplename&quot;),
                         mergedbam,
                         java_exe = get_opts(&quot;java_exe&quot;),
                         java_mem = get_opts(&quot;java_mem&quot;),
                         java_tmp = get_opts(&quot;java_tmp&quot;),
                         picard_jar = get_opts(&quot;picard_jar&quot;)){
    ## Make sure all args have a value (not null)
    ## If a variable was not defined in a conf. file get_opts, will return NULL
    check_args()  
  
  bam_list = paste(&quot;INPUT=&quot;, x, sep = &quot;&quot;, collapse = &quot; &quot;)
  ## create a named list of commands
  cmds = list(merge = sprintf(&quot;%s %s -Djava.io.tmpdir=%s -jar %s MergeSamFiles %s OUTPUT=%s ASSUME_SORTED=TRUE VALIDATION_STRINGENCY=LENIENT CREATE_INDEX=true USE_THREADING=true&quot;,java_exe, java_mem, java_tmp, picard_jar, bam_list, mergedbam))
  
  ## Create a flowmat
  flowmat = to_flowmat(cmds, samplename)
  
  ## return a list, flowmat AND outfiles
  return(list(outfiles = mergedbam, flowmat = flowmat))
}</code></pre>
<ol style="list-style-type: decimal">
<li>should accept minimum of <strong>two inputs</strong>,
<ul>
<li><strong>x</strong> (a input file etc, depends on the module) and</li>
<li>samplename (is used to append a column to the flowmat)</li>
</ul></li>
<li>should always return a list arguments:
<ul>
<li><strong>flowmat</strong> (required) : contains all the commands to run</li>
<li><strong>outfiles</strong> (recommended): could be used as an input to other tools</li>
</ul></li>
<li>can define all other default arguments such as paths to tools etc. in a seperate conf (tab-delimited) file.</li>
</ol>
<ul>
<li>Then use <code>get_opts(&quot;param&quot;)</code> to use their value.</li>
</ul>
<pre><code>## Example conf file:
cat my.conf
bwa_exe /apps/bwa/bin/bwa</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>should use <code>check_args()</code> to make sure none of the default parameters are null.</li>
</ol>
<pre class="r"><code>## check_args(), checks ALL the arguments of the function, and throws a error. use ?check_args for more details.
get_opts(&quot;my_new_tool&quot;)</code></pre>
<pre><code>## NULL</code></pre>
</div>
<div id="pipeline-structure" class="section level2">
<h2>Pipeline structure</h2>
<p>For example we have a pipeline consisting of alignment using bwa (aln1, aln2, sampe), fix rg tags using picard and merging the files. We would create three files:</p>
<pre><code>fastq_bam_bwa.R      ## A R script, with sleep_pipe(), which creates a flowmat
fastq_bam_bwa.conf   ## An *optional* tab-delim conf file, defining default params
fastq_bam_bwa.def    ## A tab-delimited flow definition file</code></pre>
<p>Notice how all files have the same basename; this is essential for the <strong>run</strong> function to find all these files.</p>
<ol style="list-style-type: decimal">
<li>all three files should have the same basename</li>
</ol>
<p><strong>Reason for using the same basename</strong>:</p>
<ul>
<li>When we call <code>run(&quot;fastq_bam_bwa&quot;, ....)</code> it tries to look for a .R file inside flowr’s package, <code>~/flowr/pipelines</code> OR your current wd. If there are multiple matches, later is chosen.</li>
<li>Then, it finds and load default parameters from <code>fastq_bam_bwa.conf</code> (if available).</li>
<li>Further, it calls the function <code>fastq_bam_bwa</code>, then stiches a flow using <code>fastq_bam_bwa.def</code> as the flow definition.</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>can have multiple flowdefs like fastq_bam_bwa_lsf.def, fastq_bam_bwa_lsf.def etc, where <basename>.def is used by default. But other are available for users to switch platforms quickly.</li>
</ol>
<p><strong>Feature</strong>:</p>
<ul>
<li>A user can supply a custom flow definition</li>
</ul>
<pre><code>run(&#39;fastq_bam_bwa&#39;, def = &#39;path/myflowdef.def&#39;....)</code></pre>
<ul>
<li>Starting flowr version <em>0.9.8.9011</em>, run also accepts a custom conf file in addition to a flowdef file. Conf contains all the default parameters like absolute paths to tools, paths to genomes, indexes etc.</li>
</ul>
<pre><code>run(&#39;fastq_bam_bwa&#39;, def = &#39;path/myflowdef.def&#39;, conf=&#39;path/myconf.conf&#39;,....)</code></pre>
<p>This is quite useful for portability, since to use the same pipeline across institution/computing clusters one only needs to change the flow definition and R function remains intact.</p>
<p>Refer to help section on <a href="rd.html#run">run</a> for more details.</p>
<div class="alert alert-info" role="alert">
<p>**<a href="Tip:**" class="uri">Tip:**</a> Its important to note, that in this example we are using R functions, but any other language can be used to create a tab-delimited flowmat file, and submitted using <code>submit_flow</code> command.</p>
</div>
</div>
<div id="nomeclature-for-parameters" class="section level2">
<h2>Nomeclature for parameters</h2>
<p>Here is a good example: <a href="https://github.com/sahilseth/flowr/blob/master/inst/pipelines/fastq_bam_bwa.conf" class="uri">https://github.com/sahilseth/flowr/blob/master/inst/pipelines/fastq_bam_bwa.conf</a></p>
<blockquote>
<p>(recommeded for increased compatibility)</p>
</blockquote>
<ol style="list-style-type: decimal">
<li>all binaries end with <strong>_exe</strong></li>
<li>all folders end with <strong>_dir</strong></li>
<li>all jar files end with <strong>_jar</strong></li>
<li>specify cpu’s using <code>&lt;%CPU%&gt;</code>, this makes this value dynamic and is picked up by the flow definition</li>
</ol>
<!--## Flow of data

Idea is that,
1. output of a **modA** can be fetched via **modA$outfiles**
2. it will be piped into say a second module B
-->
<!-- The first argument to run is the name of the pipeline, 
one may use a custom flow definition etc. Further any extra arguments supplied are passed on to the pipeline function.
For example, the `sleep_pipe` function has a argument **x** which 
determines number of tmp files to create. Default is 3, let us try changing that. -->
<!-- We then define another function `sleep_pipe` which calls the above defined **modules**; fetches flowmat from each, 
creating a larger flowmat. This time we will define a flowdef for the `sleep_pipe` function, elevating its status from
module to a pipeline.
This time we will define a flowdef for the `sleep_pipe` function, elevating its status from
module to a pipeline.
Here are a few examples of modules, three functions `sleep`, `create_tmp` and `merge_size` each returning a flowmat.
We believe pipeline and modules may be interchangeble, in the sense that a *smaller* pipeline may be 
included as part of a larger pipeline.
In flowr a module OR pipeline always returns a flowmat.
The only difference being, a pipeline also has a correspomding flow definition file. 
<div class="alert alert-info" role="alert">
As such, creating a flow definition for a module enables flowr
to run it, hence a module **elevates**, becoming a pipeline.
This lets the user mix and match several modules/pipelines to create a customized larger pipeline(s).
</div> -->
<script src = "files/googl.js"></script>
</div>
</div>


      </div>
    </div>
  </div>

  <div id="footer">
    <div class="container">
      <div class="col-md-6">
      	<p class = "pull-left">
              	<left>
        &copy; Licence MIT, 2015
      	</left>
              	</p>
      	</div>
      <div class="col-md-6">
      	<p class = "pull-right">
        	This site was made possible by
        <a href="https://github.com/rstudio/rmarkdown">rmarkdown</a>, 
        <a href="https://github.com/hadley/staticdocs">staticdocs</a> and
        <a href="https://github.com/hafen/packagedocs">packagedocs</a>
			</p>
      </div>
      	<p><center>
        Edit this page on <a href="http://github.com/sahilseth/flowr/tree/devel/vignettes/flowr_tutorial.Rmd">Github<i class='fa fa-github'></i></a>
        </center>
        </p>
    </div>
  </div>

  
</body>
</html>

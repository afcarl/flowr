<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc" />

    <meta name="author" content="Sahil Seth" />
  
    <meta name="date" content="2015-09-25" />
  
  <title>flowr</title>

    <script src="assets/jquery-1.11.0/jquery.min.js"></script>
  <link href="assets/bootstrap-3.3.2/css/bootstrap.min.css" rel="stylesheet" />
  <script src="assets/bootstrap-3.3.2/js/bootstrap.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/html5shiv.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/respond.min.js"></script>
  <link href="assets/highlight-8.4/tomorrow.css" rel="stylesheet" />
  <script src="assets/highlight-8.4/highlight.pack.js"></script>
  <link href="assets/fontawesome-4.3.0/css/font-awesome.min.css" rel="stylesheet" />
  <script src="assets/stickykit-1.1.1/sticky-kit.min.js"></script>
  <script src="assets/jqueryeasing-1.3/jquery.easing.min.js"></script>
  <link href="assets/packagedocs-0.0.1/pd.css" rel="stylesheet" />
  <script src="assets/packagedocs-0.0.1/pd.js"></script>
  <script src="assets/packagedocs-0.0.1/pd-sticky-toc.js"></script>
  
  
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>

<body>

  
  <header class="navbar navbar-white navbar-fixed-top" role="banner" id="header">
    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
                <a href="index.html" class="navbar-brand page-scroll">
        flowr - Streamlining Workflows
        </a>
      </div>
            <nav class="collapse navbar-collapse" role="navigation">
        <ul class="nav nav-pills pull-right">
<li>
<a href='docs.html'>Overview</a>
</li>
<li>
<a href='install.html'>Install</a>
</li>
<li class="active">
<a href='Tutorial.html'>Tutorial</a>
</li>
<li>
<a href='rd.html'>Help</a>
</li>
<li>
<a href='news.html'>News</a>
</li>
<li>
<a href='https://github.com/sahilseth/flowr'>Github <i class='fa fa-github'></i></a>
</li>
        </ul>
      </nav>
          </div>
  </header>

  <!-- Begin Body -->
  <div class="container">
    <div class="row">
            <div class="col-md-3" id="sidebar-col">
        <div id="toc">
          <ul>
          <li><a href="#tutorial-building-a-pipeline">Tutorial: building a pipeline</a><ul>
          <li><a href="#creating-modulespipelines">Creating Modules/Pipelines</a></li>
          <li><a href="#creating-flow-definition">Creating Flow Definition</a></li>
          <li><a href="#create-flow-submit-to-cluster">Create flow, submit to cluster</a></li>
          </ul></li>
          </ul>
        </div>
      </div>
      <div class="col-md-9" id="content-col">
      
<div id="content-top"></div>
<div id="tutorial-building-a-pipeline" class="section level1">
<h1>Tutorial: building a pipeline</h1>
<p>A pipeline consists of several pieces, most essential of which is a function which generates a <a href="http://docs.flowr.space/docs.html#flow_mat">flowmat</a>. Additionally, we need a <a href="http://docs.flowr.space/docs.html#flow_definition">flow definition</a>, which descibes flow of the pipeline. These three files are available under the <a href="https://github.com/sahilseth/flowr/tree/master/inst/pipelines">pipelines</a> folder on github.</p>
<pre><code>~/flowr/pipelines/
            |--- sleep_pipe.R      A R script, with sleep_pipe(), which creates a flowmat
            |--- sleep_pipe.def    A tab-delimited flow definition file
            |--- sleep_pipe.conf   An *optional* tab-delimited configuration file,
                                     defining default parameters</code></pre>
<p>To run the aforementioned pipeline, we would follow through these steps:</p>
<pre class="r"><code>load_opts(&quot;sleep_pipe.conf&quot;) ## optionally, load default parameters
source(&quot;sleep_pipe.R&quot;) ## get sleep_pipe() function
flowmat = sleep_pipe() ## create a flowmat
flowdef = as.flowdef(&quot;sleep_pipe.def&quot;) ## read a flow definition.
fobj = to_flow(flowmat, flowdef, execute = TRUE) ## create flow and submit to cluster

## OR assuming we have these three files in the ~/pipelines folder:
fobj = run(&quot;sleep_pipe&quot;, execute = TRUE); </code></pre>
<div id="creating-modulespipelines" class="section level2">
<h2>Creating Modules/Pipelines</h2>
<div class="alert alert-info" role="alert">
<p><strong>module</strong> A R function which creates a flow mat, is a module. Using <code>module + flowdef</code>, we can run a pipeline.</p>
</div>
<p>The <code>sleep_pipe</code> calls the three other functions (<strong>modules</strong>); fetches flowmat from each, then rbinds them, creating a larger flowmat. You may refer to the <a href="https://github.com/sahilseth/flowr/blob/master/inst/pipelines/sleep_pipe.R">sleep_pipe.R</a> file for the source.</p>
<pre class="r"><code>#&#39; @param x number of files to make
sleep_pipe &lt;- function(x = 3, samplename = &quot;samp1&quot;){

    ## call the modules one by one...
    out_sleep = sleep(x, samplename)
    out_create_tmp = create_tmp(x, samplename)
    out_merge_size = merge_size(out_create_tmp$outfiles, samplename)

    ## row bind all the commands
    flowmat = rbind(out_sleep$flowmat,
        out_create_tmp$flowmat,
        out_merge_size$flowmat)

    return(list(flowmat = flowmat, outfiles = out_merge_size$outfiles))
}</code></pre>
<pre class="r"><code>## create a flow matrix
out = sleep_pipe(x = 3, &quot;sample1&quot;)
flowmat = out$flowmat</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">samplename</th>
<th align="left">jobname</th>
<th align="left">cmd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sample1</td>
<td align="left">sleep</td>
<td align="left">sleep 6 &amp;&amp; sleep 8;echo ‘hello’</td>
</tr>
<tr class="even">
<td align="left">sample1</td>
<td align="left">sleep</td>
<td align="left">sleep 0 &amp;&amp; sleep 1;echo ‘hello’</td>
</tr>
<tr class="odd">
<td align="left">sample1</td>
<td align="left">sleep</td>
<td align="left">sleep 1 &amp;&amp; sleep 3;echo ‘hello’</td>
</tr>
<tr class="even">
<td align="left">sample1</td>
<td align="left">create_tmp</td>
<td align="left">head -c 100000 /dev/urandom &gt; sample1_tmp_1</td>
</tr>
<tr class="odd">
<td align="left">sample1</td>
<td align="left">create_tmp</td>
<td align="left">head -c 100000 /dev/urandom &gt; sample1_tmp_2</td>
</tr>
<tr class="even">
<td align="left">sample1</td>
<td align="left">create_tmp</td>
<td align="left">head -c 100000 /dev/urandom &gt; sample1_tmp_3</td>
</tr>
<tr class="odd">
<td align="left">sample1</td>
<td align="left">merge</td>
<td align="left">cat sample1_tmp_1 sample1_tmp_2 sample1_tmp_3 &gt; sample1_merged</td>
</tr>
<tr class="even">
<td align="left">sample1</td>
<td align="left">size</td>
<td align="left">du -sh sample1_merged; echo ‘MY shell:’ $SHELL</td>
</tr>
</tbody>
</table>
<p>Next, we need a flow definition.</p>
</div>
<div id="creating-flow-definition" class="section level2">
<h2>Creating Flow Definition</h2>
<p>flowr enables us to quickly create a skeleton flow definition using a flowmat, which we can then alter to suit our needs. A handy function to_flowdef, accepts a <code>flowmat</code> and creates a flow definition.</p>
<div class="alert alert-info" role="alert">
<p>The default skeleton takes a very conservative approach, creating all submissions as <code>serial</code> and all dependencies as <code>gather</code>. This ensures robustness, compromising efficiency.</p>
</div>
<pre class="r"><code>def = to_flowdef(flowmat) ## create a skeleton flow definition
suppressMessages(plot_flow(def))</code></pre>
<p><img src="tutorial_files/figure-html/plot_skeleton_def-1.png" title="" alt="" width="624" /></p>
<p>We can make the following changes to make this more efficient (run steps in parallel):</p>
<ul>
<li>multiple sleep commands would run as <code>scatter</code>/parallel (<code>none</code>)</li>
<li>For each sleep, create_tmp creates a tmp file (<code>serial</code>)</li>
<li>All tmp files are merged; when all are complete (<code>gather</code>)</li>
<li>Then we get size on the resulting file (<code>serial</code>)</li>
</ul>
<p><em>dependencies mentioned in ()</em></p>
<pre class="r"><code>def$sub_type = c(&quot;scatter&quot;, &quot;scatter&quot;, &quot;serial&quot;, &quot;serial&quot;)
def$dep_type = c(&quot;none&quot;, &quot;serial&quot;, &quot;gather&quot;, &quot;serial&quot;)
kable(def)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">jobname</th>
<th align="left">sub_type</th>
<th align="left">prev_jobs</th>
<th align="left">dep_type</th>
<th align="left">queue</th>
<th align="left">memory_reserved</th>
<th align="left">walltime</th>
<th align="right">cpu_reserved</th>
<th align="left">platform</th>
<th align="right">jobid</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sleep</td>
<td align="left">scatter</td>
<td align="left">none</td>
<td align="left">none</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">create_tmp</td>
<td align="left">scatter</td>
<td align="left">sleep</td>
<td align="left">serial</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">merge</td>
<td align="left">serial</td>
<td align="left">create_tmp</td>
<td align="left">gather</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">size</td>
<td align="left">serial</td>
<td align="left">merge</td>
<td align="left">serial</td>
<td align="left">short</td>
<td align="left">2000</td>
<td align="left">1:00</td>
<td align="right">1</td>
<td align="left">torque</td>
<td align="right">4</td>
</tr>
</tbody>
</table>
<p><img src="tutorial_files/figure-html/plot_tweaked_def-1.png" title="" alt="" width="624" /></p>
<div class="alert alert-info" role="alert">
<p><strong>Tip:</strong> Alternatively, one may write this to a file (<code>write_sheet(def, &quot;sleep_pipe.def&quot;)</code>), make changes in a text editor and read it again (<code>as.flowdef(&quot;sleep_pipe.def&quot;)</code>.</p>
</div>
</div>
<div id="create-flow-submit-to-cluster" class="section level2">
<h2>Create flow, submit to cluster</h2>
<p><strong>Next, we create a flow object:</strong></p>
<pre class="r"><code>fobj = to_flow(flowmat, def, flowname = &quot;sleep_pipe&quot;)</code></pre>
<p><strong>Finally, we can submit this to the cluster:</strong></p>
<pre class="r"><code>plot_flow(fobj)
submit_flow(fobj) ## dry run
fobj2 = submit_flow(fobj, execute = TRUE) ## submission to LSF cluster

## after submission, we can use the following:
status(fobj2) ## check status
rerun(fobj2)  ## re-run from a intermediate step
kill(fobj2)   ## kill it!</code></pre>
<!----


We then define another function `sleep_pipe` which calls the above defined **modules**; fetches flowmat from each, 
creating a larger flowmat. This time we will define a flowdef for the `sleep_pipe` function, elevating its status from
module to a pipeline.


This time we will define a flowdef for the `sleep_pipe` function, elevating its status from
module to a pipeline.




Here are a few examples of modules, three functions `sleep`, `create_tmp` and `merge_size` each returning a flowmat.

We believe pipeline and modules may be interchangeble, in the sense that a *smaller* pipeline may be 
included as part of a larger pipeline.
In flowr a module OR pipeline always returns a flowmat.
The only difference being, a pipeline also has a correspomding flow definition file. 


<div class="alert alert-info" role="alert">
As such, creating a flow definition for a module enables flowr
to run it, hence a module **elevates**, becoming a pipeline.
This lets the user mix and match several modules/pipelines to create a customized larger pipeline(s).
</div>
-->
</div>
</div>


      </div>
    </div>
  </div>

  <div id="footer">
    <div class="container">
      <div class="col-md-6">
              </div>
      <div class="col-md-6">
        <p class="pull-right">created with <a href="https://github.com/hafen/packagedocs">packagedocs</a></p>
      </div>
    </div>
  </div>

  
</body>
</html>

<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc" />

    <meta name="author" content="Sahil Seth" />
  
  
  <title>flowr</title>

    <script src="assets/jquery-1.11.0/jquery.min.js"></script>
  <link href="assets/bootstrap-3.3.2/css/bootstrap.min.css" rel="stylesheet" />
  <script src="assets/bootstrap-3.3.2/js/bootstrap.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/html5shiv.min.js"></script>
  <script src="assets/bootstrap-3.3.2/shim/respond.min.js"></script>
  <link href="assets/highlight-8.4/tomorrow.css" rel="stylesheet" />
  <script src="assets/highlight-8.4/highlight.pack.js"></script>
  <link href="assets/fontawesome-4.3.0/css/font-awesome.min.css" rel="stylesheet" />
  <script src="assets/stickykit-1.1.1/sticky-kit.min.js"></script>
  <script src="assets/jqueryeasing-1.3/jquery.easing.min.js"></script>
  <link href="assets/packagedocs-0.0.1/pd.css" rel="stylesheet" />
  <script src="assets/packagedocs-0.0.1/pd.js"></script>
  <script src="assets/packagedocs-0.0.1/pd-sticky-toc.js"></script>
  
  
  
    <style type="text/css">
  .section h1 {
    margin-top: 50px;
    margin-bottom: 70px;
    text-align: center;
    border-bottom: 0px;
    font-size: 35px;
    font-weight: 400;
    font-family: "PT Mono","Georgia",Arial,sans-serif;
  }

  .section h2 {
    margin-left: -10px !important;
    border-bottom: 3px solid #5d9fea;
  }

  </style>
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>

<body>

  
  <header class="navbar navbar-white navbar-fixed-top" role="banner" id="header">
    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
                <a href="index.html" class="navbar-brand page-scroll">
        flowr - Streamlining Workflows
        </a>
      </div>
            <nav class="collapse navbar-collapse" role="navigation">
        <ul class="nav nav-pills pull-right">
<li>
<a href='docs.html'>Overview</a>
</li>
<li>
<a href='Tutorial.html'>Tutorial</a>
</li>
<li>
<a href='install.html'>Install</a>
</li>
<li class="active">
<a href='rd.html'>Help</a>
</li>
<li>
<a href='news.html'>News</a>
</li>
<li>
<a href='https://github.com/sahilseth/flowr'>Github <i class='fa fa-github'></i></a>
</li>
        </ul>
      </nav>
          </div>
  </header>

  <!-- Begin Body -->
  <div class="container">
    <div class="row">
            <div class="col-md-3" id="sidebar-col">
        <div id="toc">
          <ul>
          <li><a href="#creating-a-flow">Creating a Flow</a><ul>
          <li><a href="#to_flow">to_flow</a></li>
          <li><a href="#to_flowmat">to_flowmat</a></li>
          <li><a href="#check">check</a></li>
          </ul></li>
          <li><a href="#submiting-and-managing-a-flow">Submiting and managing a flow</a><ul>
          <li><a href="#submit_flow">submit_flow</a></li>
          <li><a href="#plot_flow">plot_flow</a></li>
          <li><a href="#status">status</a></li>
          <li><a href="#kill">kill</a></li>
          <li><a href="#rerun">rerun</a></li>
          </ul></li>
          <li><a href="#managing-parameters">Managing parameters</a><ul>
          <li><a href="#flowopts">flowopts</a></li>
          <li><a href="#setup">setup</a></li>
          <li><a href="#verbose">verbose</a></li>
          </ul></li>
          <li><a href="#managing-pipelines">Managing pipelines</a><ul>
          <li><a href="#fetch">fetch</a></li>
          <li><a href="#run">run</a></li>
          </ul></li>
          <li><a href="#details-on-flowrs-classes">Details on flowr’s classes</a><ul>
          <li><a href="#queue">queue</a></li>
          <li><a href="#job">job</a></li>
          <li><a href="#flow">flow</a></li>
          </ul></li>
          <li><a href="#other-helpful-functions">Other helpful functions</a><ul>
          <li><a href="#get_unique_id">get_unique_id</a></li>
          <li><a href="#to_flowdet">to_flowdet</a></li>
          <li><a href="#check_args">check_args</a></li>
          <li><a href="#get_wds">get_wds</a></li>
          </ul></li>
          </ul>
        </div>
      </div>
      <div class="col-md-9" id="content-col">
      
<div id="content-top"></div>
<h1>
Streamlining Design and Deployment of Complex Workflows
</h1>

<p>
<strong>Authors:</strong> <a href="mailto:me@sahilseth.com">Sahil Seth</a> [aut, cre]
</p>
<p>
<strong>Version:</strong> 0.9.7.9029
</p>
<p>
<strong>License:</strong> MIT + file LICENSE
</p>

<h4>
Description
</h4>
<p>
An interface to streamline design of complex workflows and their deployment to a High Performance Computing Cluster.
</p>

<h4>
Depends
</h4>
<p>
R (&gt;= 3.0.2), methods, params (&gt;= 0.2.8), utils
</p>

<h4>
Imports
</h4>
<p>
diagram, whisker, tools
</p>

<h4>
Suggests
</h4>
<p>
reshape2, knitr, ggplot2, openxlsx, testthat
</p>

<h4>
Enhances
</h4>
<p>
(none)
</p>

<div id="creating-a-flow" class="section level1">
<h1>Creating a Flow</h1>
<div id="to_flow" class="section level2">
<h2>to_flow</h2>
<h3>
Create flow objects
</h3>

<p class="rd-p">
Use a set of shell commands and flow definiton to create <a href='flow.html'>flow</a> object. vector: a file with flowmat table a named list of commands for a sample. Its best to supply a flowmat instead.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>to_flow(x, ...)

to_flowcharacter(x, def, grp_col, jobname_col, cmd_col, ...)

to_flowflowmat(x, def, grp_col, jobname_col, cmd_col, flowname,
  flow_run_path, platform, submit = FALSE, execute = FALSE, qobj,
  verbose = get_opts("verbose"), ...)

to_flowdata.frame(x, ...)

to_flowlist(x, def, flowname, flow_run_path, desc, qobj,
  verbose = get_opts("verbose"), ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
path (char. vector) to flow_mat, a data.frame or a list.
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
Supplied to specific functions like <code>to_flow.data.frame</code>
</dd>
  <dt>
def
</dt>
  <dd class="rd-dd">
A flow definition table. Basically a table with resource requirements and mapping of the jobs in this flow
</dd>
  <dt>
grp_col
</dt>
  <dd class="rd-dd">
column name used to split x (flow_mat). [samplename]
</dd>
  <dt>
jobname_col
</dt>
  <dd class="rd-dd">
column name with job names. [jobname]
</dd>
  <dt>
cmd_col
</dt>
  <dd class="rd-dd">
column name with commands. [cmd]
</dd>
  <dt>
flowname
</dt>
  <dd class="rd-dd">
name of the flow [flowname]
</dd>
  <dt>
flow_run_path
</dt>
  <dd class="rd-dd">
Path to a folder. Main operating folder for this flow. [<code>get_opts(“flow_run_path”)</code>][<code>~/flowr/runs</code>].
</dd>
  <dt>
platform
</dt>
  <dd class="rd-dd">
character vector, specifying the platform to use. local, lsf, torque, moab, sge, slurm, … This over-rides the platform column in flowdef. (optional)
</dd>
  <dt>
submit
</dt>
  <dd class="rd-dd">
Use submit_flow on flow object this function returns. TRUE/FALSE. [FALSE]
</dd>
  <dt>
execute
</dt>
  <dd class="rd-dd">
Use submit_flow on flow object this function returns. TRUE/FALSE, an paramter to submit_flow(). [FALSE]
</dd>
  <dt>
qobj
</dt>
  <dd class="rd-dd">
Depreciated, modify <a href = http://docs.flowr.space/en/latest/rd/vignettes/build-pipes.html#cluster-interface>cluster templates</a> instead. A object of class <a href=#queue>queue</a>.
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
A numeric value indicating the amount of messages to produce. Values are integers varying from 0, 1, 2, 3, …. Please refer to the <a href=#verbose>verbose</a> page for more details. [<code>get_opts(“verbose”)</code>] [1]
</dd>
  <dt>
desc
</dt>
  <dd class="rd-dd">
Advanced Use. final flow name, please dont change.
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
The parameter x can be a path to a flow_mat, or a data.frame (as read by read_sheet). This is a minimum three column matrix with three columns: samplename, jobname and cmd
</p>


<h4>
Value
</h4>

<p class="rd-p"><dl>
Returns a flow object. If execute=TRUE, fobj is rich with information about where and how the flow was executed. It would include details like jobids, path to exact scripts run etc. To use kill_flow, to kill all the jobs one would need a rich flow object, with job ids present.
</p>

<p class="rd-p">
<strong>Behaviour:</strong> What goes in, and what to expect in return?
<ul>
<li> 
submit=FALSE &amp; execute=FALSE: Create and return a flow object
</li>
<li> 
submit=TRUE &amp; execute=FALSE: dry-run, Create a flow object then, create a structured execution folder with all the commands
</li>
<li> 
submit=TRUE, execute=TRUE: Do all of the above and then, submit to cluster
</li>
</ul></p>

<p class="rd-p"></dl></p>



<h4>
Examples
</h4>
<pre class="r"><code>ex = file.path(system.file(package = "flowr"), "pipelines")
flowmat = as.flowmat(file.path(ex, "sleep_pipe.tsv"))
flowdef = as.flowdef(file.path(ex, "sleep_pipe.def"))
fobj = to_flow(x = flowmat, def = flowdef, flowname = "sleep_pipe", platform = "lsf")</code></pre>



</div>
<div id="to_flowmat" class="section level2">
<h2>to_flowmat</h2>
<h3>
Taking in a named list and returns a two columns data.frame
</h3>

<p class="rd-p">
Taking in a named list and returns a two columns data.frame as.flowmat(): reads a file and checks for required columns. If x is data.frame checks for required columns.
</p>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
a named list OR vector. Where name corresponds to the jobname and value is a vector of commands to run
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
not used
</dd>
  <dt>
samplename
</dt>
  <dd class="rd-dd">
character of length 1 or that of nrow(x)
</dd>
  <dt>
grp_col
</dt>
  <dd class="rd-dd">
column used for grouping, default samplename.
</dd>
  <dt>
jobname_col
</dt>
  <dd class="rd-dd">
column specifying jobname, default jobname
</dd>
  <dt>
cmd_col
</dt>
  <dd class="rd-dd">
column specifying commands to run, default cmd
</dd>
</dl>





</div>
<div id="check" class="section level2">
<h2>check</h2>
<h3>
Check consistency of flowdef and flowmat
</h3>

<p class="rd-p">
Currently checks S3 flowdef &amp; flowmat for consistency.
</p>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
a flowdef or flowmat object
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
suppled to <code>check.classname</code> function
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
be chatty
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
<strong>A typical output from flowdef</strong> with verbose level: 2
</p>

<p class="rd-p"><pre>
    checking if required columns are present...
    checking if resources columns are present...
    checking if dependency column has valid names...
    checking if submission column has valid names...
    checking for missing rows in def...
    checking for extra rows in def...
    checking submission and dependency types...
    jobname prev.sub_type --> dep_type --> sub_type: relationship
    1: aln1_a   none --> none --> scatter
    2: aln2_a   scatter --> none --> scatter
    3: sampe_a  scatter --> serial --> scatter rel: complex one:one
    4: fixrg_a  scatter --> serial --> scatter rel: complex one:one
    5: merge_a  scatter --> gather --> serial rel: many:one
    6: markdup_a    serial --> serial --> serial rel: simple one:one
    7: target_a serial --> serial --> serial rel: simple one:one
    8: realign_a    serial --> burst --> scatter rel: one:many
    9: baserecalib_a    scatter --> serial --> scatter rel: complex one:one
    10: printreads_a    scatter --> serial --> scatter rel: complex one:one
    </pre></p>




</div>
</div>
<div id="submiting-and-managing-a-flow" class="section level1">
<h1>Submiting and managing a flow</h1>
<div id="submit_flow" class="section level2">
<h2>submit_flow</h2>
<h3>
submit_flow
</h3>


<h4>
Usage
</h4>
<pre class="r"><code>submit_flow(x, verbose = get_opts("verbose"), ...)

submit_flowlist(x, verbose = get_opts("verbose"), ...)

submit_flowflow(x, verbose = get_opts("verbose"),
  execute = FALSE, uuid, plot = TRUE, dump = TRUE, .start_jid = 1, ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
a <code>object</code> of class <code>flow</code>.
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
logical.
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
Advanced use. Any additional parameters are passed on to <a href=#submit_job>submit_job</a> function.
</dd>
  <dt>
execute
</dt>
  <dd class="rd-dd">
<code>logical</code> whether or not to submit the jobs
</dd>
  <dt>
uuid
</dt>
  <dd class="rd-dd">
<code>character</code> Advanced use. This is the final path used for flow execution. Especially useful in case of re-running a flow.
</dd>
  <dt>
plot
</dt>
  <dd class="rd-dd">
<code>logical</code> whether to make a pdf flow plot (saves it in the flow working directory).
</dd>
  <dt>
dump
</dt>
  <dd class="rd-dd">
dump all the flow details to the flow path
</dd>
  <dt>
.start_jid
</dt>
  <dd class="rd-dd">
Job to start this submission from. Advanced use, should be 1 by default.
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>submit_flow(fobj = fobj, ... = ...)</code></pre>



</div>
<div id="plot_flow" class="section level2">
<h2>plot_flow</h2>
<h3>
plot_flow
</h3>

<p class="rd-p">
plot the flow object plot_flow.character: works on a flowdef file.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>plot_flow(x, ...)

plot_flowflow(x, ...)

plot_flowlist(x, ...)

plot_flowcharacter(x, ...)

plot_flowflowdef(x, detailed = TRUE, type = c("1", "2"),
  pdf = FALSE, pdffile, ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
Object of class <code>flow</code>, or a list of flow objects or a flowdef
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
experimental
</dd>
  <dt>
detailed
</dt>
  <dd class="rd-dd">
include some details
</dd>
  <dt>
type
</dt>
  <dd class="rd-dd">
1 is original, and 2 is a elipse with less details
</dd>
  <dt>
pdf
</dt>
  <dd class="rd-dd">
create a pdf instead of plotting interactively
</dd>
  <dt>
pdffile
</dt>
  <dd class="rd-dd">
output file name for the pdf file
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>qobj = queue(type="lsf")
cmds = rep("sleep 5", 10)
jobj1 <- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")
jobj2 <- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "serial", previous_job = "job1")
fobj <- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)

### Gather: many to one relationship
jobj1 <- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")
jobj2 <- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "gather", previous_job = "job1")
fobj <- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)

### Burst: one to many relationship
jobj1 <- job(q_obj=qobj, cmd = cmds, submission_type = "serial", name = "job1")
jobj2 <- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "burst", previous_job = "job1")
fobj <- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)</code></pre>



</div>
<div id="status" class="section level2">
<h2>status</h2>
<h3>
status
</h3>

<p class="rd-p">
Summarize status of executed flow(x)
</p>

<h4>
Usage
</h4>
<pre class="r"><code>status(x, use_cache = FALSE, verbose = get_opts("verbose"),
  out_format = "markdown")

get_status(x, ...)

get_statusflow(x, verbose, use_cache, out_format, ...)

get_statuscharacter(x, verbose, use_cache, out_format, ...)

get_statusdata.frame(x, verbose, use_cache, ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
path to the flow root folder or a parent folder to summarize several flows.
</dd>
  <dt>
use_cache
</dt>
  <dd class="rd-dd">
by default is true. This skips checking status of jobs which have already been created. To get a more accurate summary, one may turn this off.
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
A numeric value indicating the amount of messages to produce. Values are integers varying from 0, 1, 2, 3, …. Please refer to the <a href=#verbose>verbose</a> page for more details. [<code>get_opts(“verbose”)</code>] [1]
</dd>
  <dt>
out_format
</dt>
  <dd class="rd-dd">
passed onto knitr:::kable. supports: markdown, rst, html…
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
not used
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
basename(x) is used in a wild card search.
</p>

<p class="rd-p"><ul>
<li> 
If x is a path with a single flow, it outputs the status of one flow.
</li>
<li> 
If the path has more than one flow then this could give a summary of <strong>all</strong> of them.
</li>
<li> 
Instead if x is supplied with paths to more than one flow, then this individually prints status of each.
</li>
</ul></p>

<p class="rd-p">
Alternatively, x can also be a flow object.
</p>

<p class="rd-p">
Use <strong>use_cache</strong> is to speed up checking status of jobs which have already been completed. Essentially this skips creation of a flow details text file if it already exists and also skips reading the trigger files for jobs whose exit code was 0, last time this was checked.
</p>



<h4>
Examples
</h4>
<pre class="r"><code>status(x = "~/flowr/runs/sleep_pipe*")
## an example for running from terminal
flowr status x=path_to_flow_directory</code></pre>



</div>
<div id="kill" class="section level2">
<h2>kill</h2>
<h3>
Kill all jobs submitted to the computing platform, for one or multiple flows
</h3>

<p class="rd-p">
<strong>A pipeline requires files which are created at the end of the submit_flow command</strong>. Even if you want to kill the flow, its best to let submit_flow do its job, when done simply use kill(flow_wd). If submit_flow is interrupted, flow_details etc files are not created, thus flowr looses the association of jobs with flow instance.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>kill(x, ...)

killcharacter(x, force = FALSE, ...)

killflow(x, kill_cmd, verbose = get_opts("verbose"),
  jobid_col = "job_sub_id", ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
either path to flow wd or object of class <a href=#flow>flow</a>
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
not used
</dd>
  <dt>
force
</dt>
  <dd class="rd-dd">
You need to set force=TRUE, to kill multiple flows. This makes sure multiple flows are NOT killed by accident.
</dd>
  <dt>
kill_cmd
</dt>
  <dd class="rd-dd">
The command used to kill. flowr tries to guess this commands, as defined in the detect_kill_cmd(). Supplying it here; fot custom platoforms.
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
A numeric value indicating the amount of messages to produce. Values are integers varying from 0, 1, 2, 3, …. Please refer to the <a href=#verbose>verbose</a> page for more details. [<code>get_opts(“verbose”)</code>] [1]
</dd>
  <dt>
jobid_col
</dt>
  <dd class="rd-dd">
Advanced use. The column name in flow_details.txt file used to fetch jobids to kill
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>## example for terminal
## flowr kill_flow x=path_to_flow_directory
## In case path matches multiple folders, flowr asks before killing
kill(x='fastq_haplotyper*')
 Flowr: streamlining workflows
 found multiple wds:
 /fastq_haplotyper-MS132-20150825-16-24-04-0Lv1PbpI
 /fastq_haplotyper-MS132-20150825-17-47-52-5vFIkrMD
 Really kill all of them ? kill again with force=TRUE

## submitting again with force=TRUE will kill them:
kill(x='fastq_haplotyper*', force = TRUE)</code></pre>



</div>
<div id="rerun" class="section level2">
<h2>rerun</h2>
<h3>
Re-run a pipeline in case of hardware or software failures.
</h3>

<p class="rd-p"><ul>
<li> 
<strong>hardware</strong> no change required, simple rerun: <code>rerun(x=flow_wd)</code>
</li>
<li> 
<strong>software</strong> either a change to flowmat or flowdef has been made: <code>rerun(x=flow_wd, mat = new_flowmat, def = new_flowdef)</code>
</li>
</ul>
<strong>NOTE:</strong> <em>flow_wd</em>: flow working directory, same input as used for <a href='status.html'>status</a>
</p>

<h4>
Usage
</h4>
<pre class="r"><code>rerun(x, ...)

reruncharacter(x, ...)

rerunflow(x, mat, def, start_from, execute = TRUE, kill = TRUE,
  select, ignore, verbose = get_opts("verbose"), ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
flow working directory
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
passed onto to_flow
</dd>
  <dt>
mat
</dt>
  <dd class="rd-dd">
(optional) flowmat fetched from previous submission if missing. For more information regarding the format refer to <a href=#to_flowmat>to_flowmat</a>
</dd>
  <dt>
def
</dt>
  <dd class="rd-dd">
(optional) flowdef fetched from previous submission if missing. For more information regarding the format refer to <a href=#to_flowdef>to_flowdef</a>
</dd>
  <dt>
start_from
</dt>
  <dd class="rd-dd">
which job to start from, this is a job name.
</dd>
  <dt>
execute
</dt>
  <dd class="rd-dd">
[logical] whether to execute or not
</dd>
  <dt>
kill
</dt>
  <dd class="rd-dd">
(optional) logical indicating whether to kill the jobs from the previous execution of flow.
</dd>
  <dt>
select
</dt>
  <dd class="rd-dd">
select a subset of jobs to rerun [character vector]
</dd>
  <dt>
ignore
</dt>
  <dd class="rd-dd">
ignore a subset of jobs to rerun [character vector]
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
A numeric value indicating the amount of messages to produce. Values are integers varying from 0, 1, 2, 3, …. Please refer to the <a href=#verbose>verbose</a> page for more details. [<code>get_opts(“verbose”)</code>] [1]
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
This function fetches details regarding the previous execution from the flow working directory (flow_wd).
</p>

<p class="rd-p">
It reads the <a href=#flow>flow</a> object from the flow_details.rds file, and extracts flowdef and flowmat from it using <a href=#to_flowmat>to_flowmat</a> and <a href=#to_flowdef>to_flowdef</a> functions.
</p>

<p class="rd-p">
<strong>New flowmat / flowdef</strong> for re-run:
</p>

<p class="rd-p">
Optionally, if either of these (flowmat or flowdef) are supplied, supplied ones are used instead for the new submission.
</p>

<p class="rd-p">
This functions efficiently updates job details of the latest submission into the previous file; thus information regarding previous job ids and their status is not lost.
</p>



<h4>
Examples
</h4>
<pre class="r"><code>rerun_flow(wd = wd, fobj = fobj, execute = TRUE, kill = TRUE)</code></pre>

</div>
</div>
<div id="managing-parameters" class="section level1">
<h1>Managing parameters</h1>
<div id="flowopts" class="section level2">
<h2>flowopts</h2>
<h3>
Default options/params used in ngsflows and flowr
</h3>

<p class="rd-p">
There are three helper functions which attempt to manage params used by flowr and ngsflows:
<ul>
<li> 
<a href='http://www.inside-r.org/packages/cran/params/docs/params'>get_opts</a> OR <code>opts_flow$get()</code>: show all default options
</li>
<li> 
<a href='http://www.inside-r.org/packages/cran/params/docs/params'>set_opts</a> OR <code>opts_flow$set()</code>: set default options
</li>
<li> 
<a href='http://www.inside-r.org/packages/cran/params/docs/params'>load_opts</a> OR <code>opts_flow$load()</code>: load options specified in a tab seperated text file
</li>
</ul>
For more details regarding these funtions refer to <a href='http://www.inside-r.org/packages/cran/params/docs/params'>params</a>.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>flowopts

get_opts(...)
set_opts(...)
load_opts(...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
…
</dt>
  <dd class="rd-dd"><ul>
<li> 
get: names of options to fetch
</li>
<li> 
set: a set of options in a name=value format seperated by commas
</li>
</ul>
</dd>
</dl>

<h4>
Format
</h4>

<p class="rd-p">
<code>opts_flow</code>
</p>


<h4>
Details
</h4>

<p class="rd-p">
By default flowr loads, <code>~/flowr/conf/flowr.conf</code> and <code>~/flowr/conf/ngsflows.conf</code>
</p>

<p class="rd-p">
Below is a list of default flowr options, retrieved via
</p>

<p class="rd-p">
<code>opts_flow$get()</code>:
<pre>
    |name              |value                    |
    |:-----------------|:------------------------|
    |default_regex     |(.*)                     |
    |flow_base_path    |~/flowr                  |
    |flow_conf_path    |~/flowr/conf             |
    |flow_parse_lsf    |.*(\<[0-9]*\>).*         |
    |flow_parse_moab   |(.*)                     |
    |flow_parse_sge    |(.*)                     |
    |flow_parse_slurm  |(.*)                     |
    |flow_parse_torque |(.?)\..*                 |
    |flow_pipe_paths   |~/flowr/pipelines        |
    |flow_pipe_urls    |~/flowr/pipelines        |
    |flow_platform     |local                    |
    |flow_run_path     |~/flowr/runs             |
    |my_conf_path      |~/flowr/conf             |
    |my_dir            |path/to/a/folder         |
    |my_path           |~/flowr                  |
    |my_tool_exe       |/usr/bin/ls              |
    |time_format       |%a %b %e %H:%M:%S CDT %Y |
    |verbose           |FALSE                    |
    </pre></p>



<h4>
Examples
</h4>
<pre class="r"><code>## Set options: set_opts()
opts = set_opts(flow_run_path = "~/mypath")
## OR if you would like to supply a long list of options:
opts = set_opts(.dots = list(flow_run_path = "~/mypath"))

## load options from a configuration file: load_opts()
conffile = fetch_conf("flowr.conf")
load_opts(conffile)

## Fetch options: get_opts()
get_opts("flow_run_path")
get_opts()</code></pre>



</div>
<div id="setup" class="section level2">
<h2>setup</h2>
<h3>
Setup and initialize some scripts.
</h3>


<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
bin
</dt>
  <dd class="rd-dd">
path to bin folder
</dd>
  <dt>
flow_base_path
</dt>
  <dd class="rd-dd">
the root folder for all flowr operations
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
Will add more to this to identify cluster and aid in other things
</p>






</div>
<div id="verbose" class="section level2">
<h2>verbose</h2>
<h3>
Verbose levels, defining verboseness of messages
</h3>

<p class="rd-p">
There are several levels of verboseness one can choose from. <strong>levels:</strong>
<ul>
<li> 
level 0 is almost silent, producing only necessary messages
</li>
<li> 
level 1 is good for most purposes, where as,
</li>
<li> 
level 2 is good when developing a new pipeline.
</li>
<li> 
level 3 is good for debugging, especially when getting un-expected results.
</li>
</ul>
One can set the level of verboseness using <code>opts_flow$set(verbose=2)</code>, which will be used across flowr and ngsflows packages. Additionally one may set this value in the configurations files: <code>~/flowr/conf/flowr.conf</code> OR <code>~/flowr/conf/ngsflows.conf</code>.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>verbose</code></pre>

<h4>
Format
</h4>

<p class="rd-p"><pre> NULL
</pre></p>



<h4>
Examples
</h4>
<pre class="r"><code>fl = system.file("pipelines/abcd.def", package = "flowr")
def = as.flowdef(fl, verbose = 0)
    # def seems to be a file, reading it...
def = as.flowdef(fl, verbose = 1)
    # def seems to be a file, reading it...
    # checking if required columns are present...
    # checking if resources columns are present...
    # checking if dependency column has valid names...
    # checking if submission column has valid names...
    # checking for missing rows in def...
    # checking for extra rows in def...
    # checking submission and dependency types...
def = as.flowdef(fl, verbose = 2)
    # def seems to be a file, reading it...
    # checking if required columns are present...
    # checking if resources columns are present...
    # checking if dependency column has valid names...
    # checking if submission column has valid names...
    # checking for missing rows in def...
    # checking for extra rows in def...
    # checking submission and dependency types...
    # jobname   prev.sub_type --> dep_type --> sub_type: relationship
    #   1: A    none --> none --> scatter
    #   2: B    scatter --> serial --> scatter rel: complex one:one
    #   3: C    scatter --> gather --> serial rel: many:one
    #   4: D    serial --> burst --> scatter rel: one:many</code></pre>

</div>
</div>
<div id="managing-pipelines" class="section level1">
<h1>Managing pipelines</h1>
<div id="fetch" class="section level2">
<h2>fetch</h2>
<h3>
Two generic functions to search for pipelines and configuration files.
</h3>

<p class="rd-p">
These functions help in searching for specific files in the user’s space. <code>fetch_pipes()</code>: Fetches pipelines in the following places, in this specific order:
<ul>
<li> 
<strong>user’s folder</strong>: <code>~/flowr/pipelines</code>
</li>
<li> 
<strong>current wd</strong>:
</li>
</ul>
<strong>NOTE:</strong> If same pipeline is availabe in multiple places; one from the later folder would be selected up. Such that, giving priority to user’s home, and current working directories. Which is what, one would intuitiuvely expect. <code>fetch_conf()</code>: Fetches configuration files in the following places:
<ul>
<li> 
<strong>package</strong>: <code>conf</code> folders in flowr and ngsflows packages.
</li>
<li> 
<strong>user’s folder</strong>: <code>~/flowr/conf</code> folder.
</li>
<li> 
<strong>current wd</strong>:
</li>
</ul>
<strong>NOTE:</strong> This function would greedily return all matching conf files. One would load all of them in the order returned by this functions. If the same variable is repeated in multiple files, value from the later files would be final. Thus ( as explained above ), giving priority to options defined in user’s home and current working directories. By default flowr loads, <code>flowr.conf</code> and <code>ngsflows.conf</code>. See the following details sections, for more explanation on this.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>fetch(x, places, urls, verbose = get_opts("verbose"))

fetch_pipes(x, places, last_only = FALSE,
  urls = get_opts("flowr_pipe_urls"), silent = FALSE,
  verbose = get_opts("verbose"), ask = TRUE)

fetch_conf(x = "flowr.conf", places, ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
name of the file to search for
</dd>
  <dt>
places
</dt>
  <dd class="rd-dd">
places (paths) to look for it. Its best to use the defaults
</dd>
  <dt>
urls
</dt>
  <dd class="rd-dd">
urls to look for, works well for pipelines.
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
be chatty?
</dd>
  <dt>
last_only
</dt>
  <dd class="rd-dd">
[fetch_pipes only]. If multiple pipelines match the pattern, return the last one.
</dd>
  <dt>
silent
</dt>
  <dd class="rd-dd">
[fetch_pipes() only]. logical, be silent even if no such pipeline is available.
</dd>
  <dt>
ask
</dt>
  <dd class="rd-dd">
ask before downloading or copying, not used !
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
not used
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
For example flowr has a variable <code>flow_run_path</code> where it puts all the execution logs etc. The default values is picked up from packagess internal <code>flowr.conf</code> file. To redefine this value, one could create a new file called <code>~/flowr/conf/flowr.conf</code> and add a line:
</p>

<p class="rd-p">
<code>flow_run_path<TAB>my_awesome_path</code>, where <TAB> is a tab character, since these are tab seperated files.
</p>

<p class="rd-p">
Also at any time you can run, <code>load_conf(super_specific_opts.conf)</code>; to load custom options.
</p>



<h4>
Examples
</h4>
<pre class="r"><code>{

## let us find a default conf file
conf = fetch_conf("flowr.conf");conf
## load this
load_opts(conf)

## this returns a list, which prints pretty
pip = fetch_pipes("sleep_pipe")
pip$name
pip$pipe
pip$def

}</code></pre>



</div>
<div id="run" class="section level2">
<h2>run</h2>
<h3>
run pipelines
</h3>

<p class="rd-p">
Running examples flows This wraps a few steps: Get all the commands to run (flow_mat) Create a <code>flow</code> object, using flow_mat and a default flowdef (picked from the same folder). Use <code>submit_flow()</code> to submit this to the cluster.
</p>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
name of the pipeline to run. This is a function called to create a flow_mat.
</dd>
  <dt>
platform
</dt>
  <dd class="rd-dd">
what platform to use, overrides flowdef
</dd>
  <dt>
def
</dt>
  <dd class="rd-dd">
flow definition
</dd>
  <dt>
flow_run_path
</dt>
  <dd class="rd-dd">
passed onto to_flow. Default it picked up from flowr.conf. Typically this is ~/flowr/runs
</dd>
  <dt>
execute
</dt>
  <dd class="rd-dd">
TRUE/FALSE
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
passed onto the pipeline function specified in x
</dd>
</dl>



</div>
</div>
<div id="details-on-flowrs-classes" class="section level1">
<h1>Details on flowr’s classes</h1>
<div id="queue" class="section level2">
<h2>queue</h2>
<h3>
Create a <code>queue</code> object which containg details about how a job is submitted.
</h3>

<p class="rd-p">
This function defines the queue used to submit jobs to the cluster. In essence details about the computing cluster in use.
</p>

<h4>
Usage
</h4>
<pre class="r"><code>queue(object, platform = c("local", "lsf", "torque", "sge", "moab"),
  format = "", queue = "long", walltime, memory, cpu = 1,
  extra_opts = "", submit_exe, nodes = "1", jobname = "name",
  email = Sys.getenv("USER"), dependency = list(), server = "localhost",
  verbose = FALSE, cwd = "", stderr = "", stdout = "", ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
object
</dt>
  <dd class="rd-dd">
this is not used currenlty, ignore.
</dd>
  <dt>
platform
</dt>
  <dd class="rd-dd">
Required and important. Currently supported values are lsf and torque. [Used by class job]
</dd>
  <dt>
format
</dt>
  <dd class="rd-dd">
[advanced use] We have a default format for the final command line string generated for lsf and torque.
</dd>
  <dt>
queue
</dt>
  <dd class="rd-dd">
the type of queue your group usually uses bsub etc.
</dd>
  <dt>
walltime
</dt>
  <dd class="rd-dd">
max walltime of a job.
</dd>
  <dt>
memory
</dt>
  <dd class="rd-dd">
The amount of memory reserved. Units depend on the platform used to process jobs
</dd>
  <dt>
cpu
</dt>
  <dd class="rd-dd">
number of cpus you would like to reserve [Used by class job]
</dd>
  <dt>
extra_opts
</dt>
  <dd class="rd-dd">
[advanced use] Extra options to be supplied while create the job submission string.
</dd>
  <dt>
submit_exe
</dt>
  <dd class="rd-dd">
[advanced use] Already defined by platform. The exact command used to submit jobs to the cluster example qsub
</dd>
  <dt>
nodes
</dt>
  <dd class="rd-dd">
[advanced use] number of nodes you would like to request. Or in case of torque name of the nodes.<em>optional</em> [Used by class job]
</dd>
  <dt>
jobname
</dt>
  <dd class="rd-dd">
[debug use] name of this job in the computing cluster
</dd>
  <dt>
email
</dt>
  <dd class="rd-dd">
[advanced use] Defaults to system user, you may put you own email though may get tons of them.
</dd>
  <dt>
dependency
</dt>
  <dd class="rd-dd">
[debug use] a list of jobs to complete before starting this one
</dd>
  <dt>
server
</dt>
  <dd class="rd-dd">
[not used] This is not implemented currently. This would specify the head node of the computing cluster. At this time submission needs to be done on the head node of the cluster where flow is to be submitted
</dd>
  <dt>
verbose
</dt>
  <dd class="rd-dd">
[logical] TRUE/FALSE
</dd>
  <dt>
cwd
</dt>
  <dd class="rd-dd">
[debug use] Ignore
</dd>
  <dt>
stderr
</dt>
  <dd class="rd-dd">
[debug use] Ignore
</dd>
  <dt>
stdout
</dt>
  <dd class="rd-dd">
[debug use] Ignore
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
other passed onto object creation. Example: memory, walltime, cpu
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
<strong>Resources</strong>: Can be defined <strong>once</strong> using a <a href=#queue>queue</a> object and recylced to all the jobs in a flow. If resources (like memory, cpu, walltime, queue) are supplied at the job level they overwrite the one supplied in <a href=#queue>queue</a> Nodes: can be supplied ot extend a job across multiple nodes. This is purely experimental and not supported.
</p>

<p class="rd-p">
<strong>Server</strong>: This a hook which may be implemented in future.
</p>

<p class="rd-p">
<strong>Submission script</strong> The platform variable defines the format, and submit_exe; however these two are avaible for someone to create a custom submission command.
</p>



<h4>
Examples
</h4>
<pre class="r"><code>qobj <- queue(platform='lsf')</code></pre>



</div>
<div id="job" class="section level2">
<h2>job</h2>
<h3>
job class
</h3>


<h4>
Usage
</h4>
<pre class="r"><code>job(cmds = "", name = "myjob", q_obj = new("queue"), previous_job = "",
  cpu = 1, memory, walltime, submission_type = c("scatter", "serial"),
  dependency_type = c("none", "gather", "serial", "burst"), ...)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
cmds
</dt>
  <dd class="rd-dd">
the commands to run
</dd>
  <dt>
name
</dt>
  <dd class="rd-dd">
name of the job
</dd>
  <dt>
q_obj
</dt>
  <dd class="rd-dd">
queue object
</dd>
  <dt>
previous_job
</dt>
  <dd class="rd-dd">
character vector of previous job. If this is the first job, one can leave this empty, NA, NULL, ., or . In future this could specify multiple previous jobs.
</dd>
  <dt>
cpu
</dt>
  <dd class="rd-dd">
no of cpus reserved
</dd>
  <dt>
memory
</dt>
  <dd class="rd-dd">
The amount of memory reserved. Units depend on the platform used to process jobs
</dd>
  <dt>
walltime
</dt>
  <dd class="rd-dd">
The amount of time reserved for this job. Format is unique to a platform. Typically it looks like 12:00 (12 hours reserved, say in LSF), in Torque etc. we often see measuring in seconds: 12:00:00
</dd>
  <dt>
submission_type
</dt>
  <dd class="rd-dd">
submission type: A character with values: scatter, serial. Scatter means all the cmds would be run in parallel as seperate jobs. Serial, they would combined into a single job and run one-by-one.
</dd>
  <dt>
dependency_type
</dt>
  <dd class="rd-dd">
depedency type. One of none, gather, serial, burst. If previous_job is specified, then this would not be none. [Required]
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
other passed onto object creation. Example: memory, walltime, cpu
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>qobj <- queue(platform="torque")

## torque job with 1 CPU running command 'sleep 2'
jobj <- job(q_obj=qobj, cmd = "sleep 2", cpu=1)

## multiple commands
cmds = rep("sleep 5", 10)

## run the 10 commands in parallel
jobj1 <- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")

## run the 10 commands sequentially, but WAIT for the previous job to complete
jobj2 <- job(q_obj=qobj, cmd = cmds, submission_type = "serial",
   dependency_type = "gather", previous_job = "job1")

fobj <- flow(jobs = list(jobj1, jobj2))

## plot the flow
plot_flow(fobj)

## dry run, only create the structure without submitting jobs
submit_flow(fobj)

## execute the jobs: ONLY works on computing cluster, would fail otherwise
submit_flow(fobj, execute = TRUE)</code></pre>



</div>
<div id="flow" class="section level2">
<h2>flow</h2>
<h3>
Flow constructor
</h3>


<h4>
Usage
</h4>
<pre class="r"><code>flow(jobs = list(new("job")), name = "newflow", desc = "my_super_flow",
  mode = c("scheduler", "trigger", "R"),
  flow_run_path = get_opts("flow_run_path"), trigger_path = "",
  flow_path = "", version = "0.0", status = "created", execute = "")

is.flow(x)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
jobs
</dt>
  <dd class="rd-dd">
<code>list</code> A list of jobs to be included in this flow
</dd>
  <dt>
name
</dt>
  <dd class="rd-dd">
<code>character</code> Name of the flow. Defaults to <code>newname</code> Used in <a href=#submit_flow>submit_flow</a> to name the working directories.
</dd>
  <dt>
desc
</dt>
  <dd class="rd-dd">
<code>character</code> Description of the flow This is used to name folders (when submitting jobs, see <a href=#submit_flow>submit_flow</a>). It is good practice to avoid spaces and other special characters. An underscore _ seems like a good word separator. Defaults to my_super_flow. We usually use this to put sample names of the data.
</dd>
  <dt>
mode
</dt>
  <dd class="rd-dd">
<code>character</code> Mode of submission of the flow.
</dd>
  <dt>
flow_run_path
</dt>
  <dd class="rd-dd">
The base path of all the flows you would submit. Defaults to <code>~/flows</code>. Best practice to ignore it.
</dd>
  <dt>
trigger_path
</dt>
  <dd class="rd-dd">
<code>character</code> Defaults to <code>~/flows/trigger</code>. Best practice to ignore it.
</dd>
  <dt>
flow_path
</dt>
  <dd class="rd-dd">
<code>character</code>
</dd>
  <dt>
version
</dt>
  <dd class="rd-dd">
version of flowr used to create and execute this flow.
</dd>
  <dt>
status
</dt>
  <dd class="rd-dd">
<code>character</code> Not used at this time
</dd>
  <dt>
execute
</dt>
  <dd class="rd-dd">
executtion status of flow object.
</dd>
  <dt>
x
</dt>
  <dd class="rd-dd">
[used by is.flow] a flow object
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>cmds = rep("sleep 5", 10)
qobj <- queue(platform='torque')
## run the 10 commands in parallel
jobj1 <- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")

## run the 10 commands sequentially, but WAIT for the previous job to complete
## Many-To-One
jobj2 <- job(q_obj=qobj, cmd = cmds, submission_type = "serial",
 dependency_type = "gather", previous_job = "job1", name = "job2")

## As soon as first job on 'job1' is complete
## One-To-One
jobj3 <- job(q_obj=qobj, cmd = cmds, submission_type = "scatter",
 dependency_type = "burst", previous_job = "job1", name = "job3")

fobj <- flow(jobs = list(jobj1, jobj2, jobj3))

## plot the flow
plot_flow(fobj)

## dry run, only create the structure without submitting jobs
submit_flow(fobj)

## execute the jobs: ONLY works on computing cluster, would fail otherwise
submit_flow(fobj, execute = TRUE)</code></pre>

</div>
</div>
<div id="other-helpful-functions" class="section level1">
<h1>Other helpful functions</h1>
<div id="get_unique_id" class="section level2">
<h2>get_unique_id</h2>
<h3>
get_unique_id
</h3>


<h4>
Usage
</h4>
<pre class="r"><code>get_unique_id(prefix = "id", suffix = "", random_length = 8)</code></pre>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
prefix
</dt>
  <dd class="rd-dd">
Default <code>id</code>. Character string to be added in the front.
</dd>
  <dt>
suffix
</dt>
  <dd class="rd-dd">
Default . Character string to be added in the end.
</dd>
  <dt>
random_length
</dt>
  <dd class="rd-dd">
Integer, defaults to 8. In our opinion 8 serves well, providing uniqueness and not being much of a eyesore.
</dd>
</dl>


<h4>
Examples
</h4>
<pre class="r"><code>get_unique_id(base = id, random_length = 8)</code></pre>



</div>
<div id="to_flowdet" class="section level2">
<h2>to_flowdet</h2>
<h3>
to_flowdet
</h3>

<p class="rd-p">
to_flowdet get a flow_details file from the directory structure. This has less information than the one generated using a flow object. Lacks jobids etc…
</p>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
this is a wd
</dd>
  <dt>
…
</dt>
  <dd class="rd-dd">
not used
</dd>
</dl>

<h4>
Details
</h4>

<p class="rd-p">
if x is char. assumed a path, check if flow object exists in it and read it. If there is no flow object, try using a simpler function
</p>






</div>
<div id="check_args" class="section level2">
<h2>check_args</h2>
<h3>
checks all the arguments in the parent frame. None of them should be null.
</h3>

<p class="rd-p">
This function may be optionally moved to a more generic package.
</p>

<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
ignore
</dt>
  <dd class="rd-dd">
optionally ignore a few variables for checking.
</dd>
  <dt>
select
</dt>
  <dd class="rd-dd">
optionally only check a few variables of the function.
</dd>
</dl>





</div>
<div id="get_wds" class="section level2">
<h2>get_wds</h2>
<h3>
Get all the (sub)directories in a folder
</h3>


<h4>
Arguments
</h4>
<dl class="rd-dl">
  <dt>
x
</dt>
  <dd class="rd-dd">
path to a folder
</dd>
</dl>






</div>
</div>


      </div>
    </div>
  </div>

  <div id="footer">
    <div class="container">
      <div class="col-md-6">
                <p>&copy; Sahil Seth, 2015</p>
              </div>
      <div class="col-md-6">
        <p class="pull-right">created with <a href="https://github.com/hafen/packagedocs">packagedocs</a></p>
      </div>
    </div>
  </div>

  
</body>
</html>
